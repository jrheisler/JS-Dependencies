<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Nurox Nexus — Used/Unused Module Map</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico" />
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <style>
    :root {
      --bg: #0b0d12;        /* dark slate */
      --panel: #121622;     /* panel ink */
      --muted: #8a93a5;     /* muted text */
      --text: #e8ecf1;      /* primary text */
      --accent: #7c5cff;    /* purple */
      --accent2: #1dd1a1;   /* teal */
      --danger: #ff5c7a;    /* pink/red */
      --warning: #f3b33d;   /* amber */
      --grid: rgba(255,255,255,.03);
      --chip: #1a2030;
      --sidebar-width: 320px;
    }
    * { box-sizing: border-box; scrollbar-width: thin; scrollbar-color: var(--accent) rgba(255,255,255,.08); }
    *::-webkit-scrollbar { width: 12px; height: 12px; }
    *::-webkit-scrollbar-track { background: rgba(9,11,18,.65); border-radius: 999px; }
    *::-webkit-scrollbar-thumb { background: linear-gradient(180deg, rgba(124,92,255,.85), rgba(29,209,161,.85)); border-radius: 999px; border: 2px solid rgba(9,11,18,.65); box-shadow: 0 2px 6px rgba(0,0,0,.35) inset; }
    *::-webkit-scrollbar-thumb:hover { background: linear-gradient(180deg, rgba(124,92,255,1), rgba(29,209,161,1)); }
    html, body { margin: 0; height: 100%; background: var(--bg); color: var(--text); font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; }
    #app { position: relative; display: grid; grid-template-columns: var(--sidebar-width) 1fr; grid-template-rows: 48px 1fr; height: 100%; transition: grid-template-columns .25s ease; }
    body.sidebar-collapsed #app { grid-template-columns: 0 1fr; }
    header { grid-column: 1 / -1; grid-row: 1; display: flex; gap: 12px; align-items: center; padding: 8px 12px; background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(0,0,0,.02)); border-bottom: 1px solid rgba(255,255,255,.06); }
    header .title { font-weight: 700; letter-spacing:.2px; }
    header .spacer { flex: 1; }
    header .status { color: var(--muted); font-size: 12px; }
    header .btn { background: var(--panel); border: 1px solid rgba(255,255,255,.08); color: var(--text); padding: 8px 10px; border-radius: 10px; cursor: pointer; transition: .2s; }
    header .btn:hover { border-color: rgba(255,255,255,.2); box-shadow: 0 0 0 2px rgba(124,92,255,.2) inset; }

    aside#sidebar { grid-column: 1; grid-row: 2; border-right: 1px solid rgba(255,255,255,.06); background: var(--panel); display: flex; flex-direction: column; gap: 12px; padding: 12px; overflow: auto; transition: transform .25s ease, opacity .25s ease; }
    body.sidebar-collapsed aside#sidebar { transform: translateX(calc(-1 * var(--sidebar-width))); opacity: 0; pointer-events: none; }
    section#canvas { position: relative; grid-column: 2; grid-row: 2; overflow: hidden; background-image: radial-gradient(circle at 25px 25px, var(--grid) 1px, transparent 0), radial-gradient(circle at 25px 25px, var(--grid) 1px, transparent 0); background-size: 50px 50px; }
    header .btn[data-variant="ghost"] { background: transparent; border-color: rgba(255,255,255,.12); }
    header .btn[data-variant="ghost"]:hover { background: rgba(255,255,255,.06); }

    .sidebar-latch { position: absolute; top: 60px; left: calc(var(--sidebar-width) - 18px); transform: translateX(-50%); display: inline-flex; align-items: center; gap: 6px; padding: 6px 12px; border-radius: 999px; border: 1px solid rgba(255,255,255,.12); background: rgba(9,11,18,.85); color: var(--text); cursor: pointer; z-index: 20; transition: left .25s ease, background .2s ease, border-color .2s ease; box-shadow: 0 8px 18px rgba(0,0,0,.35); }
    .sidebar-latch:hover { background: rgba(15,18,30,.95); border-color: rgba(255,255,255,.25); }
    .sidebar-latch .icon { font-size: 12px; }
    .sidebar-latch .label { font-size: 12px; font-weight: 600; letter-spacing: .02em; text-transform: uppercase; }
    body.sidebar-collapsed .sidebar-latch { left: 16px; }

    .group { background: #0f1320; border: 1px solid rgba(255,255,255,.06); border-radius: 12px; padding: 12px; }
    .group h3 { margin: 0 0 8px; font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: .12em; }
    input[type="text"], select { width: 100%; background: #0d1220; border: 1px solid rgba(255,255,255,.08); color: var(--text); padding: 8px 10px; border-radius: 10px; outline: none; }
    label { display: flex; align-items:center; gap: 8px; color: var(--muted); font-size: 12px; margin: 6px 0; }
    .row { display: flex; gap: 8px; align-items: center; }
    .row > * { flex: 1; }
    .pill { display: inline-flex; align-items:center; gap:6px; padding: 4px 8px; border-radius: 999px; background: var(--chip); color: var(--text); font-size: 12px; }

    /* Graph elements */
    svg { width: 100%; height: 100%; display: block; }
    .link { stroke: rgba(255,255,255,.18); stroke-width: 1.2; }
    .link.dynamic { stroke-dasharray: 3 3; opacity: .8; }
    .node circle { stroke: rgba(255,255,255,.6); stroke-width: .6; }
    .node.used circle { fill: var(--accent2); }
    .node.unused circle { fill: #273049; }
    .node.side_effect_only circle { fill: var(--warning); }
    .node.external circle { fill: #3b2f5a; }
    .label { pointer-events: none; font-size: 10px; fill: #d6def0; text-shadow: 0 1px 0 #000; opacity: .85; }
    .halo { filter: drop-shadow(0 0 6px rgba(124,92,255,.55)); }
    .node.highlighted circle { fill: #ff47d8; stroke: rgba(255,255,255,.9); stroke-width: 1.4; filter: drop-shadow(0 0 10px rgba(255,71,216,.55)); }
    .link.highlighted { stroke: #ffe45c; stroke-width: 2; }

    .legend { position: absolute; left: 12px; bottom: 12px; background: rgba(12,14,19,.85); border: 1px solid rgba(255,255,255,.06); padding: 8px 10px; border-radius: 10px; font-size: 12px; display: flex; gap: 10px; }
    .legend .key { display:flex; align-items:center; gap:6px; }
    .legend .dot { width: 10px; height: 10px; border-radius: 50%; display:inline-block; }
    .legend .metric { background: transparent; border: none; color: var(--text); font: inherit; cursor: pointer; display: inline-flex; align-items: center; gap: 6px; padding: 4px 10px; border-radius: 999px; transition: background .2s ease, color .2s ease, box-shadow .2s ease; }
    .legend .metric:hover, .legend .metric:focus-visible { background: rgba(124,92,255,.16); color: #fff; outline: none; box-shadow: 0 0 0 1px rgba(124,92,255,.35) inset; }
    .legend .metric.active { background: linear-gradient(135deg, rgba(255,71,216,.9), rgba(255,226,89,.9)); color: #11131d; box-shadow: 0 0 12px rgba(255,226,120,.45); }
    .legend .metric-sep { align-self: center; color: rgba(255,255,255,.4); }

    .stat { display: grid; grid-template-columns: auto 1fr; gap: 6px 12px; font-size: 13px; }
    .stat .k { color: var(--muted); }
    .stat .v { color: var(--text); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .hr { height: 1px; background: rgba(255,255,255,.06); margin: 6px 0; }

    .list { display: grid; gap: 6px; max-height: 200px; overflow: auto; }
    .list .item { background: #0d1220; padding: 8px; border-radius: 8px; border: 1px solid rgba(255,255,255,.06); cursor: pointer; }
    .list .item:hover { border-color: rgba(255,255,255,.2); }

    .kbd { background: #111526; border: 1px solid rgba(255,255,255,.15); border-bottom-color: rgba(0,0,0,.3); padding: 2px 6px; border-radius: 6px; font-size: 12px; }

    .modal-overlay { position: fixed; inset: 0; background: rgba(3,5,12,0.88); display: flex; align-items: center; justify-content: center; padding: 4vh 4vw; z-index: 1000; }
    .modal-overlay[hidden] { display: none; }
    .modal-shell { position: relative; width: min(1100px, 92vw); height: min(900px, 90vh); background: var(--panel); border: 1px solid rgba(255,255,255,.12); border-radius: 16px; box-shadow: 0 12px 48px rgba(0,0,0,.45); overflow: hidden; display: flex; flex-direction: column; }
    .modal-shell iframe { flex: 1; border: none; background: #fff; color-scheme: light; }
    .modal-close { position: absolute; top: 10px; right: 12px; background: rgba(9,11,18,0.8); border: 1px solid rgba(255,255,255,.2); color: var(--text); border-radius: 999px; width: 32px; height: 32px; display: grid; place-items: center; cursor: pointer; transition: .2s; font-size: 16px; }
    .modal-close:hover { border-color: rgba(255,255,255,.5); box-shadow: 0 0 0 2px rgba(124,92,255,.25) inset; }
    .modal-header { padding: 14px 44px 12px 18px; font-weight: 600; letter-spacing: .4px; border-bottom: 1px solid rgba(255,255,255,.08); background: rgba(15,18,30,.85); }
    .modal-shell iframe { border-radius: 0 0 16px 16px; }
  </style>
</head>
<body>
<div id="app">
  <header>
    <div class="title">Nurox Nexus</div>
    <div class="spacer"></div>
    <div class="status" id="status" role="status" aria-live="polite"></div>
    <button class="btn" id="openJson">Load graph.json</button>
    <input type="file" id="fileInput" accept="application/json" hidden />
    <button class="btn" id="exportSbom" title="Download SBOM CSV">SBOM CSV</button>
    <label class="btn" title="Export only the currently filtered nodes">
      <input type="checkbox" id="exportFiltered" checked style="margin-right:6px;"> Filtered only
    </label>
    <select id="colorMode" class="btn" title="Color mode">
      <option value="state">Color: State</option>
      <option value="type">Color: Type</option>
      <option value="degree">Color: Degree</option>
      <option value="package">Color: Package</option>
    </select>
    <button class="btn" id="resetView" title="Reset view">Reset View</button>
    <button class="btn" id="toggleSidebar" data-variant="ghost" aria-expanded="true" aria-controls="sidebar" title="Toggle sidebar">Hide Sidebar ◀</button>
    <button class="btn" id="pause" title="Pause/Resume physics">Pause ⏸</button>
  </header>

  <button class="sidebar-latch" id="sidebarLatch" type="button" aria-controls="sidebar" aria-expanded="true" title="Collapse sidebar">
    <span class="icon" aria-hidden="true">◀</span>
    <span class="label">Collapse</span>
  </button>

  <aside id="sidebar" aria-hidden="false">
    <div class="group">
      <h3>Search</h3>
      <input type="text" id="search" placeholder="Find node by name/path (Enter to select)" />
      <div style="margin-top:8px; color:var(--muted); font-size:12px;">Shortcuts: <span class="kbd">Ctrl/Cmd+F</span> focus search</div>
      <div style="margin-top:6px; color:var(--muted); font-size:12px;">
        Tip: drop a <code>.json</code> anywhere to load
      </div>
    </div>

    <div class="group">
      <h3>Filter</h3>
      <label><input type="checkbox" id="showUnusedOnly" /> Show unused only</label>
      <label><input type="checkbox" id="hideExternals" /> Hide externals (node_modules)</label>
      <label><input type="checkbox" id="hideDynamic" /> Hide dynamic edges</label>
      <div class="row">
        <div>
          <label for="minDegree">Min degree</label>
          <input type="range" id="minDegree" min="0" max="20" value="0" />
        </div>
        <div style="width:40px; text-align:center;" class="mono" id="minDegreeVal">0</div>
      </div>
    </div>

    <div class="group">
      <h3>Selection</h3>
      <div id="selNone" style="color:var(--muted);">Click a node to see details.</div>
      <div id="sel" style="display:none;">
        <div class="stat">
          <div class="k">Id</div><div class="v mono" id="selId"></div>
          <div class="k">Type</div><div class="v" id="selType"></div>
          <div class="k">State</div><div class="v" id="selState"></div>
          <div class="k">Package</div><div class="v" id="selPkg"></div>
          <div class="k">LOC</div><div class="v mono" id="selLoc"></div>
          <div class="k">Degree</div><div class="v mono" id="selDeg"></div>
        </div>
        <div class="hr"></div>
        <div>
          <div style="color:var(--muted); font-size:12px; text-transform:uppercase; letter-spacing:.12em; margin-bottom:6px;">Neighbors</div>
          <div class="list" id="neighbors"></div>
        </div>
      </div>
    </div>

    <div class="group">
      <h3>Insights</h3>
      <div class="stat" id="insights">
        <div class="k">Pure leaves</div><div class="v mono" id="pureLeaves">0</div>
        <div class="k">Side-effect files</div><div class="v mono" id="sideFx">0</div>
        <div class="k">Unused &amp; attached</div><div class="v mono" id="unusedAttached">0</div>
        <div class="k">Max degree</div><div class="v mono" id="maxDeg">0</div>
      </div>
    </div>

    <div class="group">
      <h3>Legend</h3>
      <div class="stat">
        <div class="k">Used</div><div class="v"><span class="pill"><span class="dot" style="background: var(--accent2);"></span> reachable</span></div>
        <div class="k">Unused</div><div class="v"><span class="pill"><span class="dot" style="background: #273049;"></span> not reached</span></div>
        <div class="k">Side-effect</div><div class="v"><span class="pill"><span class="dot" style="background: var(--warning);"></span> side-effect only</span></div>
        <div class="k">External</div><div class="v"><span class="pill"><span class="dot" style="background: #3b2f5a;"></span> node_modules</span></div>
      </div>
    </div>

    <div class="group">
      <h3>Physics</h3>
      <div class="row">
        <div>
          <label for="charge">Charge</label>
          <input type="range" id="charge" min="-4000" max="0" value="-800" />
        </div>
        <div style="width:60px; text-align:center;" class="mono" id="chargeVal">-800</div>
      </div>
      <div class="row">
        <div>
          <label for="linkDist">Link distance</label>
          <input type="range" id="linkDist" min="20" max="260" value="90" />
        </div>
        <div style="width:60px; text-align:center;" class="mono" id="linkDistVal">90</div>
      </div>
      <div class="row">
        <div>
          <label for="linkStr">Link strength</label>
          <input type="range" id="linkStr" min="0" max="1" step="0.01" value="0.07" />
        </div>
        <div style="width:60px; text-align:center;" class="mono" id="linkStrVal">0.07</div>
      </div>
    </div>

    <div class="group">
      <h3>Help</h3>
      <div style="color:var(--muted); font-size:13px; line-height:1.5;">
        • Drag nodes to pin them. Double‑click to unpin.<br>
        • Scroll to zoom. Right‑drag to pan (or use trackpad).<br>
        • <span class="kbd">H</span> toggle labels, <span class="kbd">L</span> lighten links, <span class="kbd">Space</span> pause/resume physics.<br>
        • Need more detail? Visit the <a href="help.html" id="helpLink" style="color:var(--accent);">full help guide</a>.
      </div>
    </div>
  </aside>

  <section id="canvas">
    <svg id="svg"></svg>
    <div class="legend" id="hud">
      <button type="button" class="metric" data-highlight="all">Nodes: <span id="nCount" class="mono">0</span></button>
      <span class="metric-sep" aria-hidden="true">·</span>
      <button type="button" class="metric" data-highlight="edges">Edges: <span id="eCount" class="mono">0</span></button>
      <span class="metric-sep" aria-hidden="true">·</span>
      <button type="button" class="metric" data-highlight="used">Used: <span id="uCount" class="mono">0</span></button>
      <span class="metric-sep" aria-hidden="true">·</span>
      <button type="button" class="metric" data-highlight="unused">Unused: <span id="xCount" class="mono">0</span></button>
    </div>
  </section>

</div>

<div class="modal-overlay" id="helpModal" hidden aria-hidden="true" role="dialog" aria-modal="true">
  <div class="modal-shell">
    <div class="modal-header">Help &amp; Documentation</div>
    <button class="modal-close" id="helpClose" aria-label="Close help">✕</button>
    <iframe id="helpFrame" title="Help documentation"></iframe>
  </div>
</div>

<script>
window.addEventListener('DOMContentLoaded', () => {
  // --- State ---
  let graph = { nodes: [], edges: [] };
  let filtered = { nodes: [], edges: [] };
  let showLabels = true; let dimLinks = false; let paused = false;
  let activeHighlight = null;
  const cfg = { charge: -800, linkDist: 90, linkStr: 0.07, minDegree: 0, showUnusedOnly: false, hideExternals: false, hideDynamic: false };

  // --- DOM ---
  const $ = (id)=>{
    if(typeof id === 'string' && id.startsWith('#')){
      return document.getElementById(id.slice(1));
    }
    return document.getElementById(id);
  };

  const svg = d3.select('#svg');
  const g = svg.append('g');
  const linkG = g.append('g').attr('class','links');
  const nodeG = g.append('g').attr('class','nodes');
  const labelG = g.append('g').attr('class','labels');

  const hud = $('hud');
  const hudButtons = hud ? Array.from(hud.querySelectorAll('[data-highlight]')) : [];

  function shouldHighlightNode(d){
    if(!activeHighlight) return false;
    switch(activeHighlight){
      case 'all':
        return true;
      case 'used':
        return (d.state === 'used' || d.state === 'side_effect_only');
      case 'unused':
        return d.state === 'unused';
      case 'edges':
        return ((d.inDeg || 0) + (d.outDeg || 0)) > 0;
      default:
        return false;
    }
  }

  function updateMetricState(){
    hudButtons.forEach(btn => {
      const active = activeHighlight === btn.dataset.highlight;
      btn.classList.toggle('active', active);
      btn.setAttribute('aria-pressed', active ? 'true' : 'false');
    });
  }

  function updateHighlights(){
    const nodesSel = nodeG.selectAll('g.node');
    nodesSel.classed('highlighted', d => shouldHighlightNode(d));
    nodesSel.select('circle').style('fill', d => shouldHighlightNode(d) ? '#ff47d8' : getNodeColor(d));
    const edgesSel = linkG.selectAll('line');
    const highlightEdges = activeHighlight === 'edges';
    edgesSel.classed('highlighted', highlightEdges);
    edgesSel.attr('opacity', highlightEdges ? 1 : (dimLinks ? .25 : 1));
  }

  function setHighlightFilter(next){
    const target = next || null;
    activeHighlight = (target && activeHighlight === target) ? null : target;
    updateMetricState();
    updateHighlights();
  }

  if(hudButtons.length){
    hudButtons.forEach(btn => {
      btn.setAttribute('aria-pressed', 'false');
      btn.addEventListener('click', () => setHighlightFilter(btn.dataset.highlight || null));
    });
  }

  updateMetricState();

  const zoom = d3.zoom().scaleExtent([0.1, 4]).on('zoom', (e)=>{ g.attr('transform', e.transform); });
  svg.call(zoom);

  // --- Sim ---
  const sim = d3.forceSimulation()
    .force('charge', d3.forceManyBody().strength(cfg.charge).theta(0.9))
    .force('link', d3.forceLink().id(d=>d.id).distance(cfg.linkDist).strength(cfg.linkStr))
    .force('center', d3.forceCenter())
    .force('collision', d3.forceCollide().radius(d=>sizeFor(d)+6));

  // --- UI bindings ---
  const statusEl = $('status');
  const setStatus = (msg)=>{ if(statusEl) statusEl.textContent = msg || ''; };
  const setText = (id, value)=>{ const el = $(id); if(el) el.textContent = value; };
  const setDisplay = (id, value)=>{ const el = $(id); if(el) el.style.display = value; };
  const setHTML = (id, value)=>{ const el = $(id); if(el) el.innerHTML = value; };
  const colorModeEl = $('colorMode');
  const nodeId = (ref)=> typeof ref === 'object' && ref !== null ? ref.id : ref;
  const isFileProtocol = window.location.protocol === 'file:';
  const bindSlider = (id, key, outId) => { const el = $(id); const out = $(outId);
    const update = ()=>{ cfg[key] = id==='linkStr'? parseFloat(el.value) : parseInt(el.value,10); out.textContent = el.value; if(key==='charge'){ sim.force('charge').strength(cfg.charge); } if(key==='linkDist'){ sim.force('link').distance(cfg.linkDist); } if(key==='linkStr'){ sim.force('link').strength(cfg.linkStr); } sim.alpha(0.6).restart(); };
    el.addEventListener('input', update); update(); };
  bindSlider('charge','charge','chargeVal');
  bindSlider('linkDist','linkDist','linkDistVal');
  bindSlider('linkStr','linkStr','linkStrVal');
  $('minDegree').addEventListener('input', e=>{ cfg.minDegree = parseInt(e.target.value,10); $('minDegreeVal').textContent = cfg.minDegree; render(); });
  $('showUnusedOnly').addEventListener('change', e=>{ cfg.showUnusedOnly = e.target.checked; render(); });
  $('hideExternals').addEventListener('change', e=>{ cfg.hideExternals = e.target.checked; render(); });
  $('hideDynamic').addEventListener('change', e=>{ cfg.hideDynamic = e.target.checked; render(); });
  if(colorModeEl){
    colorModeEl.addEventListener('change', ()=> {
      nodeG.selectAll('g.node').select('circle').style('fill', d => getNodeColor(d));
      updateHighlights();
    });
  }
  $('openJson').addEventListener('click', ()=> $('fileInput').click());
  $('fileInput').addEventListener('change', async (e)=>{
    const input = e.target;
    const f = input.files[0];
    if(!f) return;
    try {
      const text = await f.text();
      const parsed = JSON.parse(text);
      loadGraph(parsed);
      setStatus(`Loaded ${f.name}`);
    } catch(err) {
      console.error('Failed to load graph file', err);
      setStatus(`Failed to load ${f.name}`);
    } finally {
      input.value = '';
    }
  });
  ['dragenter','dragover'].forEach(ev => {
    window.addEventListener(ev, (e)=>{
      e.preventDefault();
      e.dataTransfer.dropEffect = 'copy';
    }, false);
  });
  window.addEventListener('drop', async (e)=>{
    e.preventDefault();
    const f = e.dataTransfer?.files?.[0];
    if(!f) return;
    try{
      const txt = await f.text();
      loadGraph(JSON.parse(txt));
      setStatus(`Loaded ${f.name}`);
    }catch(err){
      console.error(err);
      setStatus(`Failed to load ${f?.name||'drop'}`);
    }
  }, false);
  $('resetView').addEventListener('click', ()=>{ svg.transition().duration(300).call(zoom.transform, d3.zoomIdentity); });
  $('pause').addEventListener('click', ()=>{ paused = !paused; $('pause').textContent = paused ? 'Resume ▶' : 'Pause ⏸'; paused ? sim.stop() : sim.alpha(0.6).restart(); });
  $('exportSbom').addEventListener('click', exportSbom);
  const toggleSidebarBtn = $('toggleSidebar');
  const sidebarLatch = $('sidebarLatch');
  const sidebarEl = $('sidebar');
  const updateSidebarState = () => {
    const collapsed = document.body.classList.contains('sidebar-collapsed');
    if(toggleSidebarBtn){
      toggleSidebarBtn.textContent = collapsed ? 'Show Sidebar ▶' : 'Hide Sidebar ◀';
      toggleSidebarBtn.setAttribute('aria-expanded', (!collapsed).toString());
    }
    if(sidebarLatch){
      const icon = sidebarLatch.querySelector('.icon');
      const label = sidebarLatch.querySelector('.label');
      sidebarLatch.setAttribute('aria-expanded', (!collapsed).toString());
      sidebarLatch.setAttribute('title', collapsed ? 'Expand sidebar' : 'Collapse sidebar');
      if(icon){ icon.textContent = collapsed ? '▶' : '◀'; }
      if(label){ label.textContent = collapsed ? 'Expand' : 'Collapse'; }
    }
    if(sidebarEl){
      sidebarEl.setAttribute('aria-hidden', collapsed ? 'true' : 'false');
    }
  };
  const toggleSidebar = () => {
    document.body.classList.toggle('sidebar-collapsed');
    updateSidebarState();
  };
  if(toggleSidebarBtn){
    toggleSidebarBtn.addEventListener('click', toggleSidebar);
  }
  if(sidebarLatch){
    sidebarLatch.addEventListener('click', toggleSidebar);
  }
  updateSidebarState();

  const helpModal = $('helpModal');
  const helpFrame = $('helpFrame');
  const helpLink = $('helpLink');
  const helpClose = $('helpClose');
  let lastFocusedEl = null;
  const openHelp = () => {
    if(!helpModal) return;
    if(helpModal.hasAttribute('hidden')){
      lastFocusedEl = document.activeElement;
      helpModal.removeAttribute('hidden');
      helpModal.setAttribute('aria-hidden', 'false');
      if(helpFrame && !helpFrame.getAttribute('src')){
        helpFrame.setAttribute('src', 'help.html');
      }
      if(helpClose){
        helpClose.focus();
      }
    }
  };
  const closeHelp = () => {
    if(!helpModal) return;
    if(!helpModal.hasAttribute('hidden')){
      helpModal.setAttribute('hidden', '');
      helpModal.setAttribute('aria-hidden', 'true');
      if(lastFocusedEl && typeof lastFocusedEl.focus === 'function'){
        lastFocusedEl.focus();
      }
    }
  };
  if(helpLink){
    helpLink.addEventListener('click', (e)=>{
      e.preventDefault();
      openHelp();
    });
  }
  if(helpClose){
    helpClose.addEventListener('click', closeHelp);
  }
  if(helpModal){
    helpModal.addEventListener('click', (e)=>{
      if(e.target === helpModal){
        closeHelp();
      }
    });
  }
  document.addEventListener('keydown', (e)=>{
    if(e.key === 'Escape'){ closeHelp(); }
  });

  const searchEl = $('search');
  let searchTimer = null;
  let lastQuery = '';
  let lastHits = [];
  let lastIndex = -1;

  function runSearch(q){
    const hay = filtered.nodes;
    lastHits = hay.filter(n => n.id.toLowerCase().includes(q));
    lastIndex = -1;
    if(lastHits.length){
      nextHit();
    } else {
      setStatus(`No matches for "${q}"`);
    }
  }
  function nextHit(){
    if(!lastHits.length) return;
    lastIndex = (lastIndex + 1) % lastHits.length;
    const hit = lastHits[lastIndex];
    selectNode(hit);
    focusOn(hit);
    highlight(hit);
    setStatus(`Match ${lastIndex+1}/${lastHits.length}: ${hit.id}`);
  }
  if(searchEl){
    searchEl.addEventListener('input', (e)=>{
      const q = e.target.value.trim().toLowerCase();
      clearTimeout(searchTimer);
      if(!q){
        lastHits = [];
        lastIndex = -1;
        lastQuery = '';
        setStatus('');
        return;
      }
      searchTimer = setTimeout(()=>{
        if(q && q!==lastQuery){
          lastQuery=q;
          runSearch(q);
        }
      }, 150);
    });
    searchEl.addEventListener('keydown', (e)=>{
      if(e.key==='Enter'){
        e.preventDefault();
        if(searchEl.value.trim()){
          if(lastHits.length){
            nextHit();
          } else {
            runSearch(searchEl.value.trim().toLowerCase());
          }
        }
      }
    });
  }
  window.addEventListener('keydown', (e)=>{
    if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='f'){ e.preventDefault(); $('search').focus(); $('search').select(); }
    if(e.key.toLowerCase()==='h'){ showLabels = !showLabels; labelG.style('display', showLabels? null : 'none'); }
    if(e.key.toLowerCase()==='l'){ dimLinks = !dimLinks; updateHighlights(); }
    if(e.code==='Space'){ e.preventDefault(); $('pause').click(); }
  });

  // --- Helpers ---
  function sizeFor(d){
    // Prefer degree if available; fallback to 6-10 range
    const deg = (d.inDeg || 0) + (d.outDeg || 0);
    return 4 + Math.min(24, Math.sqrt(deg)*3 + (d.sizeLOC? Math.min(16, Math.log2(d.sizeLOC+1)) : 0));
  }
  function stateClass(d){ return (d.state||'unused').replace(/[^a-z_]/g,'_'); }
  function fmt(x){ return x==null? '—' : x; }
  function isExternal(d){ return d.type==='external' || (d.package && d.package.includes('node_modules')); }
  function hashToColor(str){
    // deterministic soft hues from strings (for packages)
    let h = 0; for (let i=0;i<str.length;i++) h = (h*31 + str.charCodeAt(i))>>>0;
    const hue = h % 360;
    return `hsl(${hue} 60% 55%)`;
  }
  function getNodeColor(d){
    const mode = colorModeEl ? colorModeEl.value : 'state';
    if(mode === 'type'){
      return d.type === 'external' ? '#3b2f5a' : (d.state==='unused' ? '#273049' : '#1dd1a1');
    }
    if(mode === 'degree'){
      const deg = (d.inDeg||0)+(d.outDeg||0);
      // map 0..maxDeg -> LCH-ish ramp via HSL
      const max = Math.max(1, filtered.nodes.reduce((m,n)=>Math.max(m,(n.inDeg||0)+(n.outDeg||0)),0));
      const t = Math.min(1, deg/max);
      const hue = 210 - 210*t;   // blue->red
      const sat = 60 + 20*t;
      const light = 35 + 20*t;
      return `hsl(${hue} ${sat}% ${light}%)`;
    }
    if(mode === 'package'){
      return d.package ? hashToColor(String(d.package)) :
        (d.type==='external' ? '#3b2f5a' : '#5a667e');
    }
    // default: state colors (matches CSS)
    if(d.type === 'external') return '#3b2f5a';
    if(d.state === 'side_effect_only') return '#f3b33d';
    if(d.state === 'unused') return '#273049';
    return '#1dd1a1';
  }

  function clearGraph(){
    sim.stop();
    graph = { nodes: [], edges: [] };
    filtered = { nodes: [], edges: [] };
    linkG.selectAll('*').remove();
    nodeG.selectAll('*').remove();
    labelG.selectAll('*').remove();
    setText('nCount', 0);
    setText('eCount', 0);
    setText('uCount', 0);
    setText('xCount', 0);
    setText('pureLeaves', 0);
    setText('sideFx', 0);
    setText('unusedAttached', 0);
    setText('maxDeg', 0);
    setDisplay('selNone','block');
    setDisplay('sel','none');
    setHTML('neighbors','');
  }

  function loadGraph(gjson){
    clearGraph();
    // Normalize expected schema
    graph = { nodes: (gjson.nodes||[]).map(n=>({ ...n })), edges: (gjson.edges||gjson.links||[]).map(e=>({ ...e, source: e.source, target: e.target })) };
    computeDegrees();
    inferUsageStates();
    paused = false;
    $('pause').textContent = 'Pause ⏸';
    render();
  }

  function computeDegrees(){
    const id2 = new Map(graph.nodes.map(n=>[n.id,n]));
    graph.nodes.forEach(n=>{ n.inDeg=0; n.outDeg=0; });
    graph.edges.forEach(e=>{
      const src = nodeId(e.source);
      const tgt = nodeId(e.target);
      if(id2.has(src)) id2.get(src).outDeg++;
      if(id2.has(tgt)) id2.get(tgt).inDeg++;
    });
  }

  function inferUsageStates(){
    const fileNodes = graph.nodes.filter(n=> (n.type||'file') === 'file');
    const hasFileUsage = fileNodes.some(n=> n.state && n.state !== 'unused');
    if(hasFileUsage || fileNodes.length === 0) return;

    const id2 = new Map(graph.nodes.map(n=>[n.id, n]));
    const adjacency = new Map();
    graph.edges.forEach(e=>{
      const src = nodeId(e.source);
      const tgt = nodeId(e.target);
      if(!id2.has(src) || !id2.has(tgt)) return;
      if(!adjacency.has(src)) adjacency.set(src, new Set());
      adjacency.get(src).add(tgt);
    });

    const seeds = new Set();
    fileNodes.forEach(n=>{ if(n.hasSideEffects) seeds.add(n.id); });
    graph.edges.forEach(e=>{
      if(e.kind === 'side_effect'){
        const tgt = nodeId(e.target);
        if(id2.has(tgt)) seeds.add(tgt);
      }
    });

    if(seeds.size === 0){
      fileNodes.forEach(n=>{
        const inDeg = n.inDeg || 0;
        const outDeg = n.outDeg || 0;
        if(inDeg === 0 && outDeg > 0) seeds.add(n.id);
      });
    }

    const used = new Set();
    const queue = Array.from(seeds);
    while(queue.length){
      const id = queue.shift();
      if(used.has(id)) continue;
      used.add(id);
      const next = adjacency.get(id);
      if(!next) continue;
      next.forEach(nid=>{
        if(!id2.has(nid)) return;
        const neighbor = id2.get(nid);
        if((neighbor.type||'file') === 'file' && !used.has(nid)) queue.push(nid);
      });
    }

    graph.nodes.forEach(n=>{
      if((n.type||'file') !== 'file') return;
      if(used.has(n.id)){
        const fanOut = adjacency.get(n.id);
        const hasFanOut = fanOut && fanOut.size > 0;
        if(n.hasSideEffects && (n.inDeg||0)===0 && !hasFanOut){
          n.state = 'side_effect_only';
        } else {
          n.state = 'used';
        }
      } else if(n.hasSideEffects){
        n.state = 'side_effect_only';
      } else {
        n.state = 'unused';
      }
    });
  }

  function applyFilters(){
    const nodes = graph.nodes.filter(n=>{
      if(cfg.showUnusedOnly && n.state !== 'unused') return false;
      if(cfg.hideExternals && isExternal(n)) return false;
      if(cfg.minDegree>0 && ((n.inDeg||0)+(n.outDeg||0)) < cfg.minDegree) return false;
      return true;
    });
    const keep = new Set(nodes.map(n=>n.id));
    const edges = graph.edges.filter(e=>{
      if(cfg.hideDynamic && (e.kind==='dynamic' || e.certainty==='heuristic')) return false;
      return keep.has(nodeId(e.source)) && keep.has(nodeId(e.target));
    });
    filtered = { nodes, edges };
  }

  function render(){
    applyFilters();

    // HUD counts
    setText('nCount', filtered.nodes.length);
    setText('eCount', filtered.edges.length);
    setText('uCount', filtered.nodes.filter(n=>n.state==='used'||n.state==='side_effect_only').length);
    setText('xCount', filtered.nodes.filter(n=>n.state==='unused').length);

    // Insights
    setText('pureLeaves', filtered.nodes.filter(n=> (n.inDeg||0)+(n.outDeg||0)===1 && (n.hasSideEffects===false || n.state==='unused')).length);
    setText('sideFx', filtered.nodes.filter(n=> n.state==='side_effect_only' || n.hasSideEffects===true).length);
    setText('unusedAttached', filtered.nodes.filter(n=> n.state==='unused' && ((n.inDeg||0)+(n.outDeg||0))>0).length);
    setText('maxDeg', filtered.nodes.reduce((m,n)=>Math.max(m,(n.inDeg||0)+(n.outDeg||0)),0));

    // JOINs
    const links = linkG.selectAll('line').data(filtered.edges, d=>d.id || `${nodeId(d.source)}=>${nodeId(d.target)}:${d.kind||''}`);
    links.exit().remove();
    const linksEnter = links.enter().append('line')
      .attr('class', d=> 'link '+((d.kind==='dynamic'||d.certainty==='heuristic')?'dynamic':''))
      .attr('opacity', dimLinks? .25 : 1);
    const linksSel = linksEnter.merge(links);

    const nodes = nodeG.selectAll('g.node').data(filtered.nodes, d=>d.id);
    nodes.exit().remove();
    const nodesEnter = nodes.enter().append('g').attr('class', d=>`node ${stateClass(d)} ${isExternal(d)?'external':''}`)
      .call(d3.drag()
        .on('start', (e,d)=>{ if(!e.active) sim.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
        .on('drag', (e,d)=>{ d.fx = e.x; d.fy = e.y; })
        .on('end', (e,d)=>{ if(!e.active) sim.alphaTarget(0); }))
      .on('click', (e,d)=> selectNode(d))
      .on('dblclick', (e,d)=>{ d.fx = null; d.fy = null; })
    ;

    nodesEnter.append('circle')
      .attr('r', d=> sizeFor(d))
      .attr('class','halo')
      .style('fill', d => getNodeColor(d));
    const nodesSel = nodesEnter.merge(nodes);
    nodesSel.select('circle').style('fill', d => getNodeColor(d));

    const labels = labelG.selectAll('text').data(filtered.nodes, d=>d.id);
    labels.exit().remove();
    const labelsEnter = labels.enter().append('text').attr('class','label').text(d=> labelFor(d));
    const labelsSel = labelsEnter.merge(labels);
    labelG.style('display', showLabels? null : 'none');

    updateHighlights();

    // Sim data
    sim.nodes(filtered.nodes).on('tick', ticked);
    sim.force('link').links(filtered.edges);
    if(!paused) sim.alpha(0.8).restart();

    function ticked(){
      linksSel.attr('x1', d=>d.source.x).attr('y1', d=>d.source.y).attr('x2', d=>d.target.x).attr('y2', d=>d.target.y);
      nodesSel.attr('transform', d=>`translate(${d.x},${d.y})`);
      labelsSel.attr('x', d=>d.x + sizeFor(d)+4).attr('y', d=>d.y+4);
    }
  }

  function labelFor(d){
    const id = d.id || '';
    // Shorten common path prefixes
    return id.replace(/^.*(?=src\/|lib\/|app\/)/,'').replace(/^\/?/,'');
  }

  function selectNode(n){
    setDisplay('selNone','none');
    setDisplay('sel','block');
    $('#selId').textContent = n.id || '';
    $('#selType').textContent = n.type || 'file';
    $('#selState').textContent = n.state || 'unknown';
    $('#selPkg').textContent = n.package || '—';
    $('#selLoc').textContent = fmt(n.sizeLOC);
    $('#selDeg').textContent = (n.inDeg||0)+(n.outDeg||0);

    // neighbors list
    const neighIds = new Set();
    filtered.edges.forEach(e=>{
      const src = nodeId(e.source);
      const tgt = nodeId(e.target);
      if(src===n.id) neighIds.add(tgt);
      if(tgt===n.id) neighIds.add(src);
    });
    const neigh = filtered.nodes.filter(x=> neighIds.has(x.id)).sort((a,b)=> ((b.inDeg+b.outDeg) - (a.inDeg+a.outDeg)) );
    const cont = d3.select('#neighbors');
    const items = cont.selectAll('.item').data(neigh, d=>d.id);
    items.exit().remove();
    const enter = items.enter().append('div').attr('class','item').text(d=> labelFor(d)).on('click', (_,d)=>{ selectNode(d); focusOn(d); highlight(d); });
    enter.merge(items);

    highlight(n);
  }

  function highlight(n){
    const focus = new Set([n.id]);
    filtered.edges.forEach(e=>{
      const src = nodeId(e.source);
      const tgt = nodeId(e.target);
      if(src===n.id) focus.add(tgt);
      if(tgt===n.id) focus.add(src);
    });
    d3.selectAll('g.node').attr('opacity', d=> focus.has(d.id)? 1 : .25);
    d3.selectAll('line.link').attr('opacity', d=> {
      const src = nodeId(d.source);
      const tgt = nodeId(d.target);
      return (src===n.id || tgt===n.id)? 1 : (dimLinks? .15 : .25);
    });
    d3.selectAll('text.label').attr('opacity', d=> focus.has(d.id)? 1 : .15);
    if(activeHighlight) updateHighlights();
  }

  function focusOn(n){
    const t = d3.zoomTransform(svg.node());
    const scale = t.k;
    const x = (n.x*scale*-1) + (svg.node().clientWidth/2);
    const y = (n.y*scale*-1) + (svg.node().clientHeight/2);
    svg.transition().duration(350).call(zoom.translateTo, n.x, n.y);
  }

  function exportSbom(){
    const onlyFiltered = !!($('exportFiltered') && $('exportFiltered').checked);
    const nodes = onlyFiltered ? filtered.nodes : graph.nodes;
    if(!nodes.length){
      setStatus('No graph data to export');
      return;
    }

    const headers = ['id','state','type','package','sizeLOC','hasSideEffects','external','inDegree','outDegree','degree'];
    const escape = (value) => {
      const v = value == null ? '' : String(value);
      if(/[",\n]/.test(v)){
        return '"' + v.replace(/"/g,'""') + '"';
      }
      return v;
    };

    const rows = [headers.join(',')];
    rows.push(...nodes.map(n => {
      const inDeg = n.inDeg || 0;
      const outDeg = n.outDeg || 0;
      const degree = inDeg + outDeg;
      const external = isExternal(n);
      const values = [
        n.id || '',
        n.state || '',
        n.type || '',
        n.package || '',
        n.sizeLOC ?? '',
        n.hasSideEffects ?? '',
        external,
        inDeg,
        outDeg,
        degree
      ];
      return values.map(escape).join(',');
    }));

    const blob = new Blob([rows.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'graph-sbom.csv';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    setStatus('SBOM CSV exported');
  }

  // Demo placeholder: minimal tiny graph so the page shows something if no file is loaded
  const demo = { nodes:[
    {id:'src/main.ts', state:'used', type:'file', sizeLOC: 120},
    {id:'src/util/math.ts', state:'used', type:'file', sizeLOC: 60},
    {id:'src/components/Chart.tsx', state:'used', type:'file', sizeLOC: 200},
    {id:'src/legacy/oldHelper.js', state:'unused', type:'file', sizeLOC: 40},
    {id:'node_modules/react/index.js', state:'used', type:'external' }
  ], edges:[
    {source:'src/main.ts', target:'src/util/math.ts', kind:'import'},
    {source:'src/main.ts', target:'src/components/Chart.tsx', kind:'import'},
    {source:'src/components/Chart.tsx', target:'node_modules/react/index.js', kind:'import'}
  ]};

  async function tryAutoLoad(){
    const params = new URLSearchParams(window.location.search);
    const autoTarget = params.get('load') || params.get('graph') || 'jsDependencies.json';

    if(isFileProtocol){
      setStatus('Local file mode — use “Load graph.json” to open your data.');
      loadGraph(demo);
      return;
    }
    try {
      const resp = await fetch(autoTarget, { cache: 'no-cache' });
      if(!resp.ok) throw new Error(`Missing ${autoTarget} (${resp.status})`);
      const data = await resp.json();
      loadGraph(data);
      setStatus(`Loaded ${autoTarget}`);
    } catch(err) {
      console.warn('Falling back to demo graph', err);
      setStatus('Demo graph loaded — use “Load graph.json” to open your data.');
      loadGraph(demo);
    }
  }

  tryAutoLoad();
});
</script>
</body>
</html>
